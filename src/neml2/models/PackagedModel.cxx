// Copyright 2024, UChicago Argonne, LLC
// All Rights Reserved
// Software Name: NEML2 -- the New Engineering material Model Library, version 2
// By: Argonne National Laboratory
// OPEN SOURCE LICENSE (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifdef NEML2_HAS_ZLIB
#include <zlib.h>
#endif

#include "neml2/models/PackagedModel.h"
#include "neml2/base/HITParser.h"

namespace neml2
{
void
package_model(const std::string & file,
              const std::string & name,
              std::filesystem::path output_path,
              const std::string & cliargs)
{
#ifndef NEML2_HAS_ZLIB
  throw NEMLException("NEML2 was not compiled with zlib support, cannot package models.");
#else
  namespace fs = std::filesystem;

  // load the input file and serialize the model
  auto factory = load_input(file, cliargs);
  auto inp = factory->serialize_object("Models", name);
  auto parser = HITParser();
  auto inp_str = parser.serialize(*inp);
  auto model = factory->get_model(name);

  // default output name
  if (output_path.empty())
    output_path =
        fs::path(file).parent_path() / (fs::path(file).stem().string() + "_" + name + ".gz");

  // stream the serialized model to a file
  gzFile out_file = gzopen(fs::absolute(output_path).c_str(), "wb");
  if (!out_file)
    throw NEMLException("Failed to open output file for writing: " + output_path.string());
  if (gzwrite(out_file, inp_str.c_str(), inp_str.size()) != static_cast<int>(inp_str.size()))
  {
    gzclose(out_file);
    throw NEMLException("Failed to write to output file: " + output_path.string());
  }
  if (gzclose(out_file) != Z_OK)
    throw NEMLException("Failed to close output file: " + output_path.string());
#endif
}

register_NEML2_object(PackagedModel);

OptionSet
PackagedModel::expected_options()
{
  OptionSet options = Model::expected_options();
  NonlinearSystem::enable_automatic_scaling(options);
  options.doc() = "Deserialize a packaged model and use it as a new model. The deserialized model "
                  "is a 'black box' and can be used in the same way as any other models.";

  options.set<std::string>("pkg");
  options.set("pkg").doc() =
      "Path to the packaged model file. The file must be a valid packaged model file generated by "
      "NEML2. The path can either be relative or absolute. If a relative path is provided, it "
      "will be resolved against the current working directory.";

  return options;
}

PackagedModel::PackagedModel(const OptionSet & options)
  : Model(options)
{
}

void
PackagedModel::set_value(bool out, bool dout_din, bool d2out_din2)
{
  _pkg_model->set_value(out, dout_din, d2out_din2);
}
} // namespace neml2
