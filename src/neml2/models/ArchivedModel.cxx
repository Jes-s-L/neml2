// Copyright 2024, UChicago Argonne, LLC
// All Rights Reserved
// Software Name: NEML2 -- the New Engineering material Model Library, version 2
// By: Argonne National Laboratory
// OPEN SOURCE LICENSE (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#include "neml2/base/OptionSet.h"
#ifdef NEML2_HAS_ZLIB
#include <zlib.h>
#endif

#include "neml2/models/ArchivedModel.h"
#include "neml2/base/HITParser.h"

namespace neml2
{
void
pack_model(const std::string & file,
           const std::string & name,
           std::filesystem::path output_path,
           const std::string & cliargs)
{
#ifndef NEML2_HAS_ZLIB
  throw NEMLException("NEML2 was not compiled with zlib support, cannot package models.");
#else
  namespace fs = std::filesystem;

  // load the input file and serialize the model
  auto factory = load_input(file, cliargs);
  auto inp = factory->serialize_object("Models", name);
  auto parser = HITParser(); // For now we always use HIT for serialization
  auto inp_str = parser.serialize(*inp);
  auto model = factory->get_model(name);

  // default output name
  if (output_path.empty())
    output_path =
        fs::path(file).parent_path() / (fs::path(file).stem().string() + "_" + name + ".gz");

  // stream the serialized model to a file
  gzFile out_file = gzopen(fs::absolute(output_path).c_str(), "wb");
  if (!out_file)
    throw NEMLException("Failed to open output file for writing: " + output_path.string());
  if (gzwrite(out_file, inp_str.c_str(), inp_str.size()) != static_cast<int>(inp_str.size()))
  {
    gzclose(out_file);
    throw NEMLException("Failed to write to output file: " + output_path.string());
  }
  if (gzclose(out_file) != Z_OK)
    throw NEMLException("Failed to close output file: " + output_path.string());
#endif
}

std::shared_ptr<Model>
unpack_model(const std::filesystem::path & pkg, NEML2Object * host)
{
#ifndef NEML2_HAS_ZLIB
  throw NEMLException("NEML2 was not compiled with zlib support, cannot unpack models.");
#else
  namespace fs = std::filesystem;

  // deserialize from gz
  gzFile in_file = gzopen(fs::absolute(pkg).c_str(), "rb");
  if (!in_file)
    throw NEMLException("Failed to open packaged model file for reading: " + pkg.string());
  std::string inp_str;
  std::array<char, 4096> buffer{};
  int bytes_read = 0;
  while ((bytes_read = gzread(in_file, buffer.data(), buffer.size())) > 0)
    inp_str.append(buffer.data(), bytes_read);
  if (gzclose(in_file) != Z_OK)
    throw NEMLException("Failed to close input file: " + pkg.string());

  // parse the input string
  auto parser = HITParser(); // For now we always use HIT for serialization
  auto inp = parser.parse_from_string(inp_str);
  auto factory = std::make_unique<Factory>(inp);
  OptionSet additional_options;
  additional_options.set<NEML2Object *>("host") = host;
  return factory->get_object<Model>("Models", "model", additional_options);
#endif
}

register_NEML2_object(ArchivedModel);

OptionSet
ArchivedModel::expected_options()
{
  OptionSet options = Model::expected_options();
  NonlinearSystem::enable_automatic_scaling(options);
  options.doc() =
      "Deserialize a model from an archive and use it as a new model. The deserialized model "
      "is a 'black box' and can be used in the same way as any other models.";

  options.set<std::string>("archive");
  options.set("archive").doc() =
      "Path to the archived model file. The file must be a valid archived model file generated by "
      "NEML2. The path can either be relative or absolute. If a relative path is provided, it will "
      "be resolved against the current working directory.";

  return options;
}

ArchivedModel::ArchivedModel(const OptionSet & options)
  : Model(options)
{
  // Unpack the model and squeeze it into the current factory
  auto archived_model = unpack_model(options.get<std::string>("archive"), host());
  factory()->_objects["Models"]["abcd"].push_back(archived_model);

  // now we should be able to use the model as a regular model
  _archived_model = &register_model("abcd");

  // the previous register_model call took care of input variables, so we only need to
  // clone the output variables to the current model
  for (auto && [name, var] : _archived_model->output_variables())
    clone_output_variable(*var);
}

void
ArchivedModel::link_output_variables()
{
  Model::link_output_variables();
  for (auto && [name, var] : output_variables())
    var->ref(_archived_model->output_variable(name));
}

void
ArchivedModel::set_value(bool out, bool dout_din, bool d2out_din2)
{
  _archived_model->forward_maybe_jit(out, dout_din, d2out_din2);

  // copy derivatives
  if (dout_din)
    for (auto && [name, var] : output_variables())
      var->derivatives() = _archived_model->output_variable(name).derivatives();
  if (d2out_din2)
    for (auto && [name, var] : output_variables())
      var->second_derivatives() = _archived_model->output_variable(name).second_derivatives();
}
} // namespace neml2
